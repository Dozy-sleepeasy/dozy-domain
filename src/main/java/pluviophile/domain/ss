//
// Virual Memory Simulator Homework
// One-level page table system with FIFO and LRU
// Two-level page table system with LRU
// Inverted page table with a hashing system
// Submission Year:
// Student Name:
// Student Number:
//
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#define PAGESIZEBITS 12			// page size = 4Kbytes
#define VIRTUALADDRBITS 32		// virtual address space size = 4Gbytes
int numProcess, nFrame, firstLevelBits;

struct procEntry {
	char* traceName;			// the memory trace name
	int pid;					// process (trace) id
	int ntraces;				// the number of memory traces
	int num2ndLevelPageTable;	// The 2nd level page created(allocated);
	int numIHTConflictAccess; 	// The number of Inverted Hash Table Conflict Accesses
	int numIHTNULLAccess;		// The number of Empty Inverted Hash Table Accesses
	int numIHTNonNULLAcess;		// The number of Non Empty Inverted Hash Table Accesses
	int numPageFault;			// The number of page faults
	int numPageHit;				// The number of page hits
	int done;
	struct topPageTableEntry* topPageTable;
	FILE* tracefp;
} *procTable;

struct physicalMem {
	int frameNum;
	unsigned adr;
	struct physicalMem* prev;
	struct physicalMem* next;
} *physicalEntry;

struct pageTableEntry {
	int frameNum;
	unsigned adr;
} *pageTable;

struct physicalMem firstPMem;


struct physicalMem* lastFrame() {
	struct physicalMem* curr;
	curr = &firstPMem;
	while (curr->next != curr) {
		curr = curr->next;
	}
	return curr;
}

void putFrame(struct physicalMem* pt) {
	pt->prev = lastPageTable();
	pt->next = pt;
	lastFrame()->next = pt;
}
void popFrame(struct physicalMem* pt) {
	if (pt->next == pt) {
		pt->prev->next = pt->prev;
		pt->prev = pt;
	}
	else {
		pt->prev->next = pt->next;
		pt->next->prev = pt->prev;
		pt->next = pt->prev = pt;
	}
}

void initPageTable() {
	int i;
	physicalEntry[0].frameNum = 0;
	physicalEntry[0].prev = &firstPMem;
	physicalEntry[0].next = &physicalEntry[1];
	for (i = 1; i < nFrame - 1; i++) {
		physicalEntry[i].frameNum = i;
		physicalEntry[i].prev = &physicalEntry[i - 1];
		physicalEntry[i].next = &physicalEntry[i + 1];
	}
	physicalEntry[nFrame - 1].frameNum = nFrame - 1;
	physicalEntry[nFrame - 1].prev = &physicalEntry[nFrame - 2];
	physicalEntry[nFrame - 1].next = &physicalEntry[nFrame - 1];
	firstPMem.next = &physicalEntry[0];
	firstPMem.frameNum = -1;
}
void initprocEntry() {
	int i;
	for (i = 0; i < numProcess; i++) {
		procTable[i].pid = i;
		procTable[i].ntraces = 0;
		procTable[i].num2ndLevelPageTable = 0;
		procTable[i].numIHTConflictAccess = 0;
		procTable[i].numIHTNULLAccess = 0;
		procTable[i].numIHTNonNULLAcess = 0;
		procTable[i].numPageFault = 0;
		procTable[i].numPageHit = 0;
		procTable[i].done = 0;
	}
}

void FIFO(unsigned address) {
	struct physicalMem* cur;
	cur = firstPMem.next;
	popFrame(cur);
	putFrame(cur);
	cur->adr = address;
	printf("changed!! %d", address);
}
void FIFOpaging(unsigned address, struct procEntry* proc) {
	struct physicalMem* cur;
	printf("start FIFOpaging\n");
	cur = &firstPMem;
	printf("cur = %d\n", cur->frameNum);
	while (cur->next != cur) {
		printf("do while %d\n", cur->frameNum);
		if (cur->adr == address) {	//hit
			printf("hit!! %x\n", address);
			proc->numPageHit++;
			return;
		}
		cur = cur->next;
	}
	if (cur->adr == address) {	//hit
		printf("hit!! %x\n", address);
		proc->numPageHit++;
		return;
	}
	printf("fault!! %x\n", address);
	proc->numPageFault++;
	FIFO(address);
}
void LRU(unsigned address) {
	struct physicalMem* cur;
	cur = firstPMem.next;
	popFrame(cur);
	putFrame(cur);
	cur->adr = address;
	printf("changed!! %d", address);
}
void LRUpaging(unsigned address, struct procEntry* proc) {
	struct physicalMem* cur;
	printf("start LRUpaging\n");
	cur = &firstPMem;
	printf("cur = %d\n", cur->frameNum);
	while (cur->next != cur) {
		printf("do while %d\n", cur->frameNum);
		if (cur->adr == address) {	//hit
			printf("hit!! %x\n", address);
			proc->numPageHit++;
			popFrame(cur);
			putFrame(cur);
			return;
		}
		cur = cur->next;
	}
	if (cur->adr == address) {	//hit
		printf("hit!! %x\n", address);
		proc->numPageHit++;
		popFrame(cur);
		putFrame(cur);
		return;
	}
	printf("fault!! %x\n", address);
	proc->numPageFault++;
	LRU(address);
}
void oneLevelVMSimFIFO() {
	int i;
	unsigned addr;
	char rw;
	while (1) {
		int runningProc = numProcess;
		for (i = 0; i < numProcess; i++) {
			if (!feof(procTable[i].tracefp)) {	//아직 파일을 다읽은게 아니라면
				runningProc--;
				fscanf(procTable[i].tracefp, "%x %c\n", &addr, &rw);
				addr = addr >> 12;
				printf("proc %d  have %x\n", i, addr);
				printf("do FIFOpaging\n");
				procTable[i].ntraces++;
				FIFOpaging(addr, &procTable[i]);

				int i;
				for (i = 0; i < nFrame; i++) {
					printf("frameNum %d adr %d\n", physicalEntry[i].frameNum, physicalEntry[i].adr);
				}
			}
		}
		if (runningProc == numProcess)
			break;
	}


	for (i = 0; i < numProcess; i++) {
		printf("**** %s *****\n", procTable[i].traceName);
		printf("Proc %d Num of traces %d\n", i, procTable[i].ntraces);
		printf("Proc %d Num of Page Faults %d\n", i, procTable[i].numPageFault);
		printf("Proc %d Num of Page Hit %d\n", i, procTable[i].numPageHit);
		assert(procTable[i].numPageHit + procTable[i].numPageFault == procTable[i].ntraces);
	}

}
void oneLevelVMSimLRU() {
	int i;
	unsigned addr;
	char rw;
	while (1) {
		int runningProc = numProcess;
		for (i = 0; i < numProcess; i++) {
			if (!feof(procTable[i].tracefp)) {	//아직 파일을 다읽은게 아니라면
				runningProc--;
				fscanf(procTable[i].tracefp, "%x %c\n", &addr, &rw);
				addr = addr >> 12;
				printf("proc %d  have %x\n", i, addr);
				printf("do LRUpaging\n");
				procTable[i].ntraces++;
				LRUpaging(addr, &procTable[i]);

				int i;
				for (i = 0; i < nFrame; i++) {
					printf("frameNum %d adr %d\n", physicalEntry[i].frameNum, physicalEntry[i].adr);
				}
			}
		}
		if (runningProc == numProcess)
			break;
	}


	for (i = 0; i < numProcess; i++) {
		printf("**** %s *****\n", procTable[i].traceName);
		printf("Proc %d Num of traces %d\n", i, procTable[i].ntraces);
		printf("Proc %d Num of Page Faults %d\n", i, procTable[i].numPageFault);
		printf("Proc %d Num of Page Hit %d\n", i, procTable[i].numPageHit);
		assert(procTable[i].numPageHit + procTable[i].numPageFault == procTable[i].ntraces);
	}

}

void twoLevelVMSim() {
	int i;
	unsigned addr;
	char rw;
	int secondLevelBit = VIRTUALADDRBITS - PAGESIZEBITS - firstLevelBits;
	while (1) {
		int runningProc = numProcess;
		for (i = 0; i < numProcess; i++) {
			if (!feof(procTable[i].tracefp)) {	//아직 파일을 다읽은게 아니라면
				runningProc--;
				fscanf(procTable[i].tracefp, "%x %c\n", &addr, &rw);
				addr = addr >> 12;

				procTable[i].ntraces++;
				LRUpaging(addr, &procTable[i]);

				int i;
				for (i = 0; i < nFrame; i++) {
					printf("frameNum %d adr %d\n", physicalEntry[i].frameNum, physicalEntry[i].adr);
				}
			}
		}
		if (runningProc == numProcess)
			break;
	}

	for (i = 0; i < numProcess; i++) {
		printf("**** %s *****\n", procTable[i].traceName);
		printf("Proc %d Num of traces %d\n", i, procTable[i].ntraces);
		printf("Proc %d Num of second level page tables allocated %d\n", i, procTable[i].num2ndLevelPageTable);
		printf("Proc %d Num of Page Faults %d\n", i, procTable[i].numPageFault);
		printf("Proc %d Num of Page Hit %d\n", i, procTable[i].numPageHit);
		assert(procTable[i].numPageHit + procTable[i].numPageFault == procTable[i].ntraces);
	}
}
/*
void invertedPageVMSim(...) {

	for (i = 0; i < numProcess; i++) {
		printf("**** %s *****\n", procTable[i].traceName);
		printf("Proc %d Num of traces %d\n", i, procTable[i].ntraces);
		printf("Proc %d Num of Inverted Hash Table Access Conflicts %d\n", i, procTable[i].numIHTConflictAccess);
		printf("Proc %d Num of Empty Inverted Hash Table Access %d\n", i, procTable[i].numIHTNULLAccess);
		printf("Proc %d Num of Non-Empty Inverted Hash Table Access %d\n", i, procTable[i].numIHTNonNULLAcess);
		printf("Proc %d Num of Page Faults %d\n", i, procTable[i].numPageFault);
		printf("Proc %d Num of Page Hit %d\n", i, procTable[i].numPageHit);
		assert(procTable[i].numPageHit + procTable[i].numPageFault == procTable[i].ntraces);
		assert(procTable[i].numIHTNULLAccess + procTable[i].numIHTNonNULLAcess == procTable[i].ntraces);
	}
}
*/
int main(int argc, char* argv[]) {
	int i, c, simType, phyMemSizeBits;
	simType = atoi(argv[1]);
	firstLevelBits = atoi(argv[2]);
	phyMemSizeBits = atoi(argv[3]);
	numProcess = argc - 4;

	procTable = (struct procEntry*)malloc(sizeof(struct procEntry) * numProcess);
	// initialize procTable for Memory Simulations
	for (i = 0; i < numProcess; i++) {
		// opening a tracefile for the process
		printf("process %d opening %s\n", i, argv[i + 4]);
		procTable[i].tracefp = fopen(argv[i + 4], "r");
		procTable[i].traceName = argv[i + 4];
		if (procTable[i].tracefp == NULL) {
			printf("ERROR: can't open %s file; exiting...", argv[i + 4]);
			exit(1);
		}
	}
	nFrame = 1;
	for (i = 0; i < phyMemSizeBits - PAGESIZEBITS; i++)
		nFrame *= 2;

	initPageTable();
	initprocEntry();
	printf("Num of Frames %d Physical Memory Size %ld bytes\n", nFrame, (1L << phyMemSizeBits));
	printf("%d", lastPageTable()->frameNum);
	if (simType == 0) {
		physicalEntry = (struct physicalMem*)malloc(sizeof(struct physicalMem) * nFrame);
		printf("=============================================================\n");
		printf("The One-Level Page Table with FIFO Memory Simulation Starts .....\n");
		printf("=============================================================\n");
		oneLevelVMSimFIFO();
	}
	if (simType == 1) {
		physicalEntry = (struct physicalMem*)malloc(sizeof(struct physicalMem) * nFrame);
		printf("=============================================================\n");
		printf("The One-Level Page Table with LRU Memory Simulation Starts .....\n");
		printf("=============================================================\n");
		oneLevelVMSimLRU();
	}
	if (simType == 2) {
		printf("=============================================================\n");
		printf("The Two-Level Page Table Memory Simulation Starts .....\n");
		printf("=============================================================\n");
		twoLevelVMSim(...);
	}
	return(0);
}

